<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Run command dialog">
		<meta name="author" content="max1220">
		<title>Application demo</title>
		<link rel="stylesheet" href="/static/css/xp/style.css">
		<link rel="stylesheet" href="/static/css/xp/application.css">
		<style>
			#command_output {
				overflow: auto;
				max-height: 200px;
			}
			.return {
				color: #555;
			}
		</style>
	</head>
	<body onload="onload()">
		<div class="window-content">
			<h1>Application demo</h1>
			<p>
				This document is intended to demonstrate the basic building blocks an application with persistent state.<br>
				It implements a simple command-runner using the cgi_command.js, and encodes it's UI state AppState.js.<br>
				State values default to the HTML default values if provided,<br>
				but can also be overridden via the hash part of the URL.<br>
				Updates to the state.data value automatically update HTML elements and hash.
				<br>
			</p>
			<div class="container">
				<div class="field-row">
					<label for="command_str">Command:</label>
					<input type="text" data-update-key="command_str" data-update-type="input-text" data-update-onchange value="ls -lah" style="margin-left: 1em;width: 100%;">
				</div>
				<div class="field-row">
					<label for="merge_stderr">merge stderr into stdin</label>
					<input type="checkbox" name="merge_stderr" id="merge_stderr" data-update-key="merge_stderr" data-update-type="input-boolean" data-update-onchange checked>
				</div>
				<div class="field-row">
					<span>Run mode:</span>
					<div>
							<input type="radio" name="mode" id="mode_run" data-update-key="mode_run" data-update-type="input-boolean" data-update-onchange checked>
							<label for="mode_run">complete</label>
							<br>

							<input type="radio" name="mode" id="mode_lines" data-update-key="mode_lines" data-update-type="input-boolean" data-update-onchange>
							<label for="mode_lines">stream lines</label>
							<br>

							<input type="radio" name="mode" id="mode_bytes" data-update-key="mode_bytes" data-update-type="input-boolean" data-update-onchange>
							<label for="mode_bytes">stream bytes</label>
					</div>
				</div>
				<div class="field-row">
					<button class="btn" onclick="btn_run_command()" style="width: 100%">Run</button>
				</div>
				<hr>
				<p>Output:</p>
				<pre id="command_output" class="container"></pre>
			</div>
		</div>

		<script src="/static/js/fix_radio_onchange.js"></script>
		<script src="/static/js/make_xhr.js"></script>
		<script src="/static/js/CgiCommands.js"></script>
		<script src="/static/js/AppState.js"></script>
		<script>
			"use strict";
			// fix that clicking a radio buttons doesn't call onchange on all affected elementss
			add_onchange_radio_dispatch_others()

			// create a new wrapper to call CGI commands
			let cgi_commands = new CgiCommands("/cgi-bin/cgi_command.sh")

			// create an application state object to manage
			let state = new AppState({})

			// add some parameters that will be HTML and hash-encoded automatically
			state.add_key_parameters("command_str", "text", true, true)
			state.add_key_parameters("mode_run", "boolean", true, true)
			state.add_key_parameters("merge_stderr", "boolean", true, true)
			state.add_key_parameters("mode_lines", "boolean", true, true)
			state.add_key_parameters("mode_bytes", "boolean", true, true)

			function onload() {
				state.load()
			}

			// the run_command button(run the command using eval on the server)
			function btn_run_command() {
				let command_str = state.data.command_str
				document.getElementById("command_output").innerText = ""
				console.log("Running command:", command_str)
				let command = ["eval", command_str]
				let merge_stderr = state.data.merge_stderr
				if (state.data.mode_run) {
					cgi_commands.run_command_async(eval_cb, command, undefined,undefined,undefined, undefined, merge_stderr)
				} else {
					let bytes = state.data.mode_bytes
					let stdout_cb = bytes ? stream_stdout_byte_cb : stream_stdout_line_cb
					cgi_commands.run_command_event_stream(command, undefined, merge_stderr, bytes, stdout_cb, stream_stderr_cb, stream_ret_cb)
				}
			}

			// append a new span element with the specified text and class_list to elem
			function append_span(elem, class_list, text) {
				let text_span = document.createElement("span")
				text_span.innerText = text
				text_span.classList = class_list
				elem.appendChild(text_span)
			}

			// get the output element
			let output_elem = document.getElementById("command_output")

			// got a complete command output
			function eval_cb(str) {
				append_span(output_elem, "complete", str)
			}

			// got a line of output
			function stream_stdout_line_cb(str) {
				append_span(output_elem, "line", str + "\n")
			}

			// got a byte of output
			function stream_stdout_byte_cb(str) {
				append_span(output_elem, "char", str)
			}

			// command returned
			function stream_ret_cb(status_code) {
				append_span(output_elem, "return", "return code: " + status_code + "\n")
			}

			// got a line of error
			function stream_stderr_cb(str) {
				let text_span = document.createElement("span")
				text_span.innerText = str + "\n"
				text_span.classList = "stderr_line"
				document.getElementById("command_output").appendChild(text_span)
			}
		</script>
	</body>
<!--
These values are read outside of the iframe
to determine the prefered size of this window:
{{{window_width=600}}}
{{{window_height=620}}}
{{{window_resizeable}}}
-->
</html>
